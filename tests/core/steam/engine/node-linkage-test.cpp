/*
  NodeLinkage(Test)  -  verify proper render node operation and calldown

  Copyright (C)         Lumiera.org
    2009,               Hermann Vosseler <Ichthyostega@web.de>

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of
  the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

* *****************************************************/

/** @file node-linkage-test.cpp
 ** unit test \ref NodeLinkage_test
 */


#include "lib/test/run.hpp"
#include "steam/engine/proc-node.hpp"
#include "steam/engine/node-builder.hpp"
#include "steam/engine/test-rand-ontology.hpp" ///////////TODO
#include "lib/test/diagnostic-output.hpp"/////////////////TODO
#include "lib/util.hpp"


using util::isnil;
//using std::string;
using util::isSameObject;


namespace steam {
namespace engine{
namespace test  {
  
  
  
  
  /***************************************************************//**
   * @test demonstrate and document how [render nodes](\ref proc-node.hpp)
   *       are connected into a processing network, allowing to _invoke_
   *       a \ref Port on a node to pull-generate a render result.
   *     - the foundation layer is formed by the nodes as linked into a network
   *     - starting from any Port, a TurnoutSystem can be established
   *     - which in turn allows _turn out_ a render result from this port.
   */
  class NodeLinkage_test : public Test
    {
      virtual void
      run (Arg)
        {
          seedRand();
          
          build_connected_nodes();
          generate_turnout_system();
          trigger_node_port_invocation();
        }
      
      
      
      
      /** @test TODO Build render nodes linked into a connectivity network
       * @todo WIP 7/24 üîÅ define ‚ü∂ ‚úî implement
       */
      void
      build_connected_nodes()
        {
          auto con = prepareNode("Test:Src")
                        .preparePort()
                          .invoke(DUMMY_FUN_ID, dummyOp)
                          .completePort()
                        .build();
          CHECK (isnil (con.leads));
          CHECK (1 == con.ports.size());
          
          // can build a ProcNode with this connectivity
          ProcNode n1{move(con)};
          CHECK (watch(n1).isValid());
          CHECK (watch(n1).leads().empty());
          CHECK (watch(n1).ports().size() == 1);
          
          // can generate a symbolic spec to describe the Port's processing functionality...
          CHECK (watch(n1).getPortSpec(0) == "Test:Src.dummyFun(TestFrame)"_expect);
          CHECK (watch(n1).getPortSpec(1) == "‚ÜØ"_expect);
          
          // such a symbolic spec is actually generated by a deduplicated metadata descriptor 
          auto& meta1  = ProcID::describe("N1","(arg)");
          auto& meta1b = ProcID::describe("N1","(arg)");
          auto& meta2  = ProcID::describe("N2","(arg)");
          auto& meta3  = ProcID::describe("N1","uga()");
          CHECK (    isSameObject (meta1,meta1b));
          CHECK (not isSameObject (meta1,meta2));
          CHECK (not isSameObject (meta1,meta3));
          CHECK (hash_value(meta1) == hash_value(meta1b));
          CHECK (hash_value(meta1) != hash_value(meta2));
          CHECK (hash_value(meta1) != hash_value(meta3));
          
          CHECK (meta1.genProcSpec() == "N1(arg)"_expect);
          CHECK (meta2.genProcSpec() == "N2(arg)"_expect);
          CHECK (meta3.genProcSpec() == "N1.uga()"_expect);
          
          // re-generate the descriptor for the source node (n1)
          auto& metaN1 = ProcID::describe("Test:Src",DUMMY_FUN_ID);
          CHECK (metaN1.genProcSpec() == "Test:Src.dummyFun(TestFrame)"_expect);
SHOW_EXPR(metaN1.genProcName())
          CHECK (metaN1.genProcName() == "Test:Src.dummyFun"_expect);
SHOW_EXPR(metaN1.genNodeName())
          CHECK (metaN1.genNodeName() == "Test:Src"_expect);
SHOW_EXPR(metaN1.genNodeSpec(con.leads))
          CHECK (metaN1.genNodeSpec(con.leads) == "Test:Src-‚óé"_expect);
        }
      
      
      /** @test TODO Use existing node connectivity to generate a TurnoutSystem
       * @todo WIP 7/24 üîÅ define ‚ü∂ implement
       */
      void
      generate_turnout_system()
        {
          UNIMPLEMENTED ("use existing node connectivity to generate a TurnoutSystem");
        }
      
      
      /** @test TODO Invoke some render nodes as linked together
       * @todo WIP 7/24 üîÅ define ‚ü∂ implement
       */
      void
      trigger_node_port_invocation()
        {
          UNIMPLEMENTED ("operate some render nodes as linked together");
        }
    };
  
  
  /** Register this test class... */
  LAUNCHER (NodeLinkage_test, "unit node");
  
  
  
}}} // namespace steam::engine::test
