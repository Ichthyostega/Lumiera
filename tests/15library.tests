TESTING "Library Test Suite: basic and low-level components" ./test-suite --group=common



TEST "casting or converting access helper" AccessCasted_test <<END
out-lit: can_downcast<B,D>     = 1
out-lit: can_downcast<B*,D*>   = 1
out-lit: can_downcast<B&,D&>   = 1
out-lit: can_downcast<B&,D*>   = 0
out-lit: can_downcast<B*,D&>   = 0
out-lit: can_downcast<B*&,D*&> = 1
out-lit: can_downcast<D*&,D*&> = 1
out-lit: can_downcast<D*,E*>   = 1
out-lit: can_downcast<E*,F*>   = 1
out-lit: has_RTTI<D*> = 0
out-lit: has_RTTI<E*> = 1
out-lit: has_RTTI<F*> = 1
out-lit: is_convertible<D,D&>  = 0
out-lit: is_convertible<D&,D>  = 1
out-lit: can_use_dynamic_downcast<D,D&>  = 0
out-lit: can_use_conversion<D,D&>        = 0
out-lit: can_use_dynamic_downcast<B*,D*> = 0
out-lit: can_use_conversion<D*,B*>       = 1
out-lit: can_use_dynamic_downcast<D*&,D*&> = 0
out-lit: can_use_conversion<D*&,D*&>       = 1
out-lit: can_use_conversion<D*,E*>         = 0
out-lit: can_use_dynamic_downcast<D*&,E*>  = 0
out-lit: can_use_conversion<E*,F*>         = 0
out-lit: can_use_dynamic_downcast<E*,F*>   = 1
out-lit: === standard case: References ===
out: Access\(D  as D&\) .+D.. adr=╲\w{8} ↗«D»
out: Access\(D& as D&\) .+D.. adr=╲\w{8} ↗«D»
out-lit: === build a value object ===
out: Access.D  as D.    .+D.. adr=╲\w{8} ↗«D»
out: Access.D& as D.    .+D.. adr=╲\w{8} ↗«D»
out: Access.D&& as D.   .+D.. adr=╲\w{8} ↗«D»
out-lit: === take a pointer ===
out: Access.D  as D\*.  .+╲\w{8}
out: Access.D& as D\*.  .+╲\w{8}
out-lit: === dereference a pointer ===
out: Access.D\* as D&.  .+D.. adr=╲\w{8} ↗«D»
out: Access.D\* as D.   .+D.. adr=╲\w{8} ↗«D»
out: Access.D\*&& as D. .+D.. adr=╲\w{8} ↗«D»
out-lit: === const correctness ===
out: Access.D  as D const&.       .+D.. adr=╲\w{8} ↗«D»
out: Access.D& as D const&.       .+D.. adr=╲\w{8} ↗«D»
out: Access.D  as const D.        .+D.. adr=╲\w{8} ↗«D»
out: Access.D& as const D.        .+D.. adr=╲\w{8} ↗«D»
out: Access.D  as const D\*.      .+╲\w{8}
out: Access.D& as const D\*.      .+╲\w{8}
out: Access.D\* as D const&.      .+D.. adr=╲\w{8} ↗«D»
out: Access.D\* as const D.       .+D.. adr=╲\w{8} ↗«D»
out: Access.const D  as D const&. .+D.. adr=╲\w{8} ↗«D»
out: Access.D const& as D const&. .+D.. adr=╲\w{8} ↗«D»
out: Access.const D  as const D.  .+D.. adr=╲\w{8} ↗«D»
out: Access.D const& as const D.  .+D.. adr=╲\w{8} ↗«D»
out: Access.const D  as const D\*..+╲\w{8}
out: Access.D const& as const D\*..+╲\w{8}
out: Access.const D\* as D const&..+D.. adr=╲\w{8} ↗«D»
out: Access.const D\* as const D. .+D.. adr=╲\w{8} ↗«D»
out: Access.D const& as D.        .+D.. adr=╲\w{8} ↗«D»
out: Access.D const&& as D.       .+D.. adr=╲\w{8} ↗«D»
out-lit: === work cases: actual conversions ===
out: Access.B& as B&.             .+B.. adr=╲\w{8} ↗«B»
out: Access.D& as B&.             .+B.. adr=╲\w{8} ↗«B»
out: Access.B\* as B\*.           .+╲\w{8}
out: Access.D\* as B\*.           .+╲\w{8}
out: Access.D& as B\*.            .+╲\w{8}
out: Access.D\* as B&.            .+B.. adr=╲\w{8} ↗«B»
out: Access.B\*& as B\*&.         .+╲\w{8}
out: Access.D\*& as D\*&.         .+╲\w{8}
out: Access.D& as const B\*.      .+╲\w{8}
out: Access.D\* as B const&.      .+B.. adr=╲\w{8} ↗«B»
out: Access.D const& as const B\*..+╲\w{8}
out: Access.const D\* as B const&..+B.. adr=╲\w{8} ↗«B»
out: Access.E\(F\)& as F&.        .+F.. adr=╲\w{8} ↗«F»
out: Access.E\(F\)\* as F\*.      .+╲\w{8}
out: Access.E\(F\)\* as F&.       .+F.. adr=╲\w{8} ↗«F»
out: Access.E\(F\)& as F\*.       .+╲\w{8}
out: Access.F\\* as X\*.          .+╲\w{8}
out: Access.X\(F\)\* as X\*.      .+╲\w{8}
out: Access.F\* as B&.            .+B.. adr=╲\w{8} ↗«B»
out: Access.F\* as E&*.           .+E.. adr=╲\w{8} ↗«F»
out-lit: Access(int as double) --->2
out-lit: Access(float as long) --->3
return: 0
END


TEST "CmdlineWrapper_test" CmdlineWrapper_test <<END
out-lit: wrapping cmdline:...
out-lit: -->
out-lit: wrapping cmdline:
out-lit: 	 ...
out-lit: -->
out-lit: wrapping cmdline:spam...
out-lit: 0|spam|
out-lit: -->spam
out-lit: wrapping cmdline:
out-lit: spam...
out-lit: 0|spam|
out-lit: -->spam
out-lit: wrapping cmdline:eat more spam...
out-lit: 0|eat|
out-lit: 1|more|
out-lit: 2|spam|
out-lit: -->eat more spam
out-lit: wrapping cmdline: oo _O()O_  ☭ + €...
out-lit: 0|oo|
out-lit: 1|_O()O_|
out-lit: 2|☭|
out-lit: 3|+|
out-lit: 4|€|
out-lit: -->oo _O()O_ ☭ + €
out-lit: wrapping cmdline:Ω	ooΩ	oΩo	Ωoo...
out-lit: 0|Ω|
out-lit: 1|ooΩ|
out-lit: 2|oΩo|
out-lit: 3|Ωoo|
out-lit: -->Ω ooΩ oΩo Ωoo
out-lit: Standard Cmdlineformat:one  two
return: 0
END


TEST "CustomSharedPtr_test" CustomSharedPtr_test <<END
return: 0
END


TEST "Deleter function collection" DelStash_test <<END
return: 0
END


TEST "Dependency injection" DependencyFactory_test <<END
out-lit: ctor TargetObj(0) successful
out-lit: ctor TargetObj(1) successful
out-lit: ctor TargetObj(2) successful
out-lit: ctor TargetObj(3) successful
out-lit: dtor ~TargetObj(3) successful
out-lit: ctor TargetObj(4) successful
out-lit: dtor ~TargetObj(4) successful
out-lit: dtor ~TargetObj(2) successful
out-lit: dtor ~TargetObj(1) successful
out-lit: dtor ~TargetObj(0) successful
return: 0
END


TEST "Diff: apply list diff to target sequence" DiffListApplication_test <<END
return: 0
END


TEST "Diff: compare sequences to generate list diff" DiffListGeneration_test <<END
return: 0
END


TEST "Diff: lookup table helper" DiffIndexTable_test <<END
return: 0
END


TEST "Diff: reshape a tree data structure through diff" DiffTreeApplication_test <<END
return: 0
END


TEST "A Digxel (numeric component)" Digxel_test <<END
out-lit: empty____## +0.0 ##
out-lit: value____##-88.8 ##
out: timings\(\w+\)....*ns
return: 0
END


TEST "Digxel standard configurations" DigxelConfigurations_test <<END
out-lit: Digxel<int, digxel::Formatter<int> >--empty--  0--(val=123)--123|
out-lit: Digxel<double, digxel::Formatter<double> >--empty--00.000--(val=123.457)--123.457|
out-lit: Digxel<int, digxel::SexaFormatter>--empty--00--(val=42)--42|
out-lit: Digxel<int, digxel::SexaFormatter>--empty--00--(val=-5)---5|
out-lit: Digxel<unsigned int, digxel::HexaFormatter>--empty--00--(val=12)--0C|
out-lit: Digxel<unsigned int, digxel::HexaFormatter>--empty--00--(val=111)--6F|
out-lit: Digxel<long, digxel::CountFormatter>--empty--0000--(val=-1234567890)---1234567890|
return: 0
END


TEST "plain entry-ID" EntryID_test <<END
out: ID<Dummy>-Dummy.0..
out: ID<Dummy>-strange
out: ID<Dummy>-Dummy.0..
out: ID<Fork>-Fork.0..
out: ID<Fork>-special
out: sizeof\( idi::EntryID<Fork> \) .+ =
out: sizeof\( idi::BareEntryID \)   .+ =
return: 0
END


TEST "formatting/string conversion in output" FormatCOUT_test <<END
return: 0
END


TEST "formatting/diagnostics helpers" FormatHelper_test <<END
return: 0
END


TEST "formatting by string template" FormatString_test <<END
out-lit: --format-template--int=0012--double=+1.23--string=Lumiera  --
out: 0x....+ _____+ .
out-lit: «test::FormatString_test::Silent»
out-lit: __nix_
out-lit: ____
out-lit: __1__
out-lit: __1__
out-lit: __⟂__
out-lit: __dirt__
out-lit: __1234__
out-lit: __0xff__
return: 0
END


TEST "Generic ID generation" GenericIdFunction_test <<END
return: 0
END


TEST "Generic Object Record" GenericRecordRepresentation_test <<END
out-lit: enterprise = Rec(starship| Name = USS Enterprise, Registry = NCC-1701-D, Class = Galaxy, Owner = United Federation of Planets, Operator = Starfleet, built = 2363 |{Picard, Riker, Data, Troi, Worf, Crusher, La Forge})
out-lit: Name = USS Enterprise
out-lit: Registry = NCC-1701-D
out-lit: Class = Galaxy
out-lit: Owner = United Federation of Planets
out-lit: Operator= Starfleet
out-lit: built=2363
out-lit: Picard
out-lit: Riker
out-lit: Data
out-lit: Troi
out-lit: Worf
out-lit: Crusher
out-lit: La Forge
out-lit: --Attributes--
out-lit: Name = USS Enterprise
out-lit: Registry = NCC-1701-D
out-lit: Class = Galaxy
out-lit: Owner = United Federation of Planets
out-lit: Operator= Starfleet
out-lit: built=2363
out-lit: --Keys--->Name<->Registry<->Class<->Owner<->Operator<->built
out-lit: --Vals--->USS Enterprise<->NCC-1701-D<->Galaxy<->United Federation of Planets<->Starfleet<->2363
out-lit: --Crew--->Picard | Riker | Data | Troi | Worf | Crusher | La Forge
return: 0
END


TEST "Generic Record - Mutations" GenericRecordUpdate_test <<END
return: 0
END


TEST "Generic Record data node" GenNodeBasic_test <<END
out: GenNode.+_CHILD_Record.+Rec.spam..ham = DataCap.+eggs
out-lit: --spam--
out: GenNode.+"baked beans".+Rec...hasSpam = DataCap.«bool».true.+«char».+«string».*«double».+GenNode.+"spam".+«Record<GenNode>».+«string».eggs.+«string».spam.+«string».spam
out: GenNode.+"hasSpam".+«bool».true
out: GenNode.+_CHILD_char.+«char».\*
out: GenNode.+_CHILD_string.+«string».★
out: GenNode.+_CHILD_double.+«double».3.1415927
out: GenNode.+"spam".+«Record<GenNode>».Rec.ham.+eggs.+spam.+spam
out: GenNode.+_CHILD_string.+«string».eggs
out: GenNode.+_CHILD_string.+«string».spam
out: GenNode.+_CHILD_TimeSpan.+«TimeSpan»|0:00:00.000≺920ms≻
out: GenNode.+_CHILD_long.+«long.+42
return: 0
END


PLANNED "GenericTreeRepresentation_test" GenericTreeRepresentation_test <<END
return: 0
END


PLANNED "Generic mapping of changes to tree data" TreeManipulationBinding_test <<END
return: 0
END


TEST "Generic recursive mutation with closure binding" TreeMutator_test <<END
out: concrete TreeMutator .+Builder<ChangeOperation<TreeMutator, test::TreeMutator_test::simpleAttributeBinding().+lambda\(string\).+> >
out-lit: "data" closure received something that would be acceptable
out-lit: localData changed to: that would be acceptable
return: 0
END


TEST "HashGenerator_test" HashGenerator_test <<END
return: 0
END


TEST "HashIndexed_test" HashIndexed_test <<END
return: 0
END


TEST "bridge boost::hash to std::hash" HashStandardToBoostBridge_test <<END
return: 0
END


TEST "Hierarchy rebuilding" HierarchyOrientationIndicator_test <<END
return: 0
END


TEST "configurable Factory" MultiFact_test <<END
END


TEST "Family of Singleton Factories" MultiFactSingleton_test <<END
out: Impl-1
out: Impl-2
out: Impl-3
out: Impl-4
out: sizeof\( .+MultiFact.+Interface.+theID.+PassAsIs.+ \) =
return: 0
END


TEST "Factory argument handling" MultiFactArgument_test  <<END
out: sizeof\( .+MultiFact.+Num.+prodID.+BuildRefcountPtr.+ \) =
out: fabricate\(1, 2\)
out: fabricate\(2, 3\)
return: 0
END


TEST "NIL object singleton" NullValue_test  <<END
return: 0
END


TEST "inline type erasure" OpaqueHolder_test  <<END
out: 1
out: 3
out: 5
out: 7
out: sizeof\( Base .                          =.+[12468]{1,2}
out: sizeof\( Special .                       =.+[12468]{1,2}
out: sizeof\( OpaqueHolder<Base, ........     =.+[12468]{1,2}
return: 0
END


TEST "inline unchecked buffer" OpaqueUncheckedBuffer_test  <<END
out: DD<0>:
out-lit: DD<5>: *****
out-lit: DD<9>: I'm fine*
out-lit: I'm special, what the f** is going on here?************
return: 0
END


TEST "inline val/ref wrapper" ItemWrapper_test <<END
out: ItemWrapper: sizeof\( wrapper::ItemWrapper<.+ =   .
return: 0
END


TEST "switchable reference" OptionalRef_test <<END
return: 0
END


TEST "RefArray_test" RefArray_test  <<END
return: 0
END


TEST "RemoveFromSet_test" RemoveFromSet_test <<END
out-lit: removed  nothing  ---> [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
out-lit: removed 0 ---> [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
out-lit: removed 9 ---> [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
out-lit: removed 5 ---> [ 0, 1, 2, 3, 4, 6, 7, 8, 9 ]
out-lit: removed 0   2   4   6   8   ---> [ 1, 3, 5, 7, 9 ]
out-lit: removed   1   3   5   7   9 ---> [ 0, 2, 4, 6, 8 ]
out-lit: removed 0 1 2 3 4 5 6 7 8 9 ---> [  ]
out-lit: removed 0 1 2 3 4 5 6 7 8   ---> [ 9 ]
out-lit: removed   1 2 3 4 5 6 7 8 9 ---> [ 0 ]
out-lit: removed 0 1 2 3 4   6 7 8 9 ---> [ 5 ]
return: 0
END


TEST "SanitizedIdentifier_test" SanitizedIdentifier_test <<END
out-lit: 'Word' --> 'Word'
out-lit: 'a Sentence' --> 'a_Sentence'
out-lit: 'trailing Withespace
out-lit:        	' --> 'trailing_Withespace'
out-lit: 'with    a  	 lot
out-lit:   of Whitespace' --> 'with_a_lot_of_Whitespace'
out-lit: 'with"much (punctuation)[]!' --> 'withmuch_(punctuation)'
out-lit: '§&Ω%€  leading garbage' --> 'leading_garbage'
out-lit: 'mixed    Ω   garbage' --> 'mixed_garbage'
out-lit: 'Bääääh!!' --> 'Bh'
out-lit: '§&Ω%€' --> ''
return: 0
END


TEST "ScopedHolder_test" ScopedHolder_test <<END
out: checking ScopedHolder<Dummy>...
out: checking ScopedPtrHolder<Dummy>...
return: 0
END


TEST "ScopedHolderTransfer_test" ScopedHolderTransfer_test <<END
out-lit: checking ScopedHolder<Dummy>...
out-lit: .
out-lit: ..install one element at index[0]
out-lit: .
out-lit: ..*** resize table to 16 elements
out-lit: .
out-lit: .throw some exceptions...
out-lit: checking ScopedPtrHolder<Dummy>...
out-lit: .
out-lit: ..install one element at index[0]
out-lit: .
out-lit: ..*** resize table to 16 elements
out-lit: .
out-lit: .throw some exceptions...
return: 0
END


TEST "Managed Collection (I)" ScopedCollection_test <<END
return: 0
END


TEST "Managed Collection (II)" ScopedPtrVect_test <<END
return: 0
END


TEST "Search path walking" SearchPathSplitter_test <<END
out-lit: ➢➢a
out-lit: ➢➢a
out-lit: ➢➢a
out-lit: ➢➢b
out-lit: ➢➢a
out-lit: ➢➢b
out-lit: ➢➢c
out: ➢➢.d.
out-lit: ➢➢ e f
out-lit: ➢➢/usr/bin
out-lit: ➢➢/usr/lib
return: 0
END


TEST "Singleton_test" Singleton_test 23 <<END
out-lit: testing TargetObj(23) as Singleton
out-lit: ctor TargetObj(23) successful
out-lit: calling a non-static method on the Singleton instance
out-lit: .....TargetObj(23): data="***********************", array[23]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,}
out-lit: dtor ~TargetObj(23) successful
return: 0
END


TEST "SingletonSubclass_test" SingletonSubclass_test 13 <<END
out-lit: using the Singleton should create TargetObj(13)...
out-lit: ctor TargetObj(13) successful
out-lit: calling a non-static method on the Singleton-Implementation
out-lit: .....TargetObj(13): data="*************", array[13]={0,1,2,3,4,5,6,7,8,9,10,11,12,}
out-lit: dtor ~TargetObj(13) successful
return: 0
END


TEST "SingletonTestMock_test" SingletonTestMock_test <<END
out-lit: TestSingletonO::doIt() call=1
out-lit: TestSingletonO::doIt() call=2
out-lit: Mock_1::doIt() call=1
out-lit: Mock_1::doIt() call=2
out-lit: Mock_1::doIt() call=3
out-lit: Mock_1::doIt() call=4
out-lit: Mock_1::doIt() call=5
out-lit: Mock_2::doIt() call=1
out-lit: TestSingletonO::doIt() call=3
return: 0
END


TEST "Symbol_test" Symbol_test  <<END
out: one
out: sizeof. Literal.+  =   (4|8)
out-lit: string
out-lit: string
out-lit: one....one
return: 0
END


TEST "Hashtable with Symbol keys" SymbolHashtable_test  <<END
return: 0
END


TEST "extensible symbolic identifier" SubID_test <<END
out: ....RGB
out: id1=R.12
out: id2=G.13
out: verify...
out: Elements in hashtable: 3
out: verify...
out: Elements in hashtable: 5
return: 0
END


TEST "integer rounding utility" UtilFloordiv_test <<END
return: 0
END


TEST "integer scale wrapping utility" UtilFloorwrap_test <<END
out-lit: --------int--------12/4
out-lit:  12 / 4 = 3  % = 0     floor= 3.0  wrap = ( 3, 0)
out-lit:  11 / 4 = 2  % = 3     floor= 2.0  wrap = ( 2, 3)
out-lit:  10 / 4 = 2  % = 2     floor= 2.0  wrap = ( 2, 2)
out-lit:   9 / 4 = 2  % = 1     floor= 2.0  wrap = ( 2, 1)
out-lit:   8 / 4 = 2  % = 0     floor= 2.0  wrap = ( 2, 0)
out-lit:   7 / 4 = 1  % = 3     floor= 1.0  wrap = ( 1, 3)
out-lit:   6 / 4 = 1  % = 2     floor= 1.0  wrap = ( 1, 2)
out-lit:   5 / 4 = 1  % = 1     floor= 1.0  wrap = ( 1, 1)
out-lit:   4 / 4 = 1  % = 0     floor= 1.0  wrap = ( 1, 0)
out-lit:   3 / 4 = 0  % = 3     floor= 0.0  wrap = ( 0, 3)
out-lit:   2 / 4 = 0  % = 2     floor= 0.0  wrap = ( 0, 2)
out-lit:   1 / 4 = 0  % = 1     floor= 0.0  wrap = ( 0, 1)
out-lit:   0 / 4 = 0  % = 0     floor= 0.0  wrap = ( 0, 0)
out-lit:  -1 / 4 = 0  % =-1     floor=-1.0  wrap = (-1, 3)
out-lit:  -2 / 4 = 0  % =-2     floor=-1.0  wrap = (-1, 2)
out-lit:  -3 / 4 = 0  % =-3     floor=-1.0  wrap = (-1, 1)
out-lit:  -4 / 4 =-1  % = 0     floor=-1.0  wrap = (-1, 0)
out-lit:  -5 / 4 =-1  % =-1     floor=-2.0  wrap = (-2, 3)
out-lit:  -6 / 4 =-1  % =-2     floor=-2.0  wrap = (-2, 2)
out-lit:  -7 / 4 =-1  % =-3     floor=-2.0  wrap = (-2, 1)
out-lit:  -8 / 4 =-2  % = 0     floor=-2.0  wrap = (-2, 0)
out-lit:  -9 / 4 =-2  % =-1     floor=-3.0  wrap = (-3, 3)
out-lit: -10 / 4 =-2  % =-2     floor=-3.0  wrap = (-3, 2)
out-lit: -11 / 4 =-2  % =-3     floor=-3.0  wrap = (-3, 1)
out-lit: -12 / 4 =-3  % = 0     floor=-3.0  wrap = (-3, 0)
out-lit: --------int--------12/-4
out-lit:  12 /-4 =-3  % = 0     floor=-3.0  wrap = (-3, 0)
out-lit:  11 /-4 =-2  % = 3     floor=-3.0  wrap = (-3,-1)
out-lit:  10 /-4 =-2  % = 2     floor=-3.0  wrap = (-3,-2)
out-lit:   9 /-4 =-2  % = 1     floor=-3.0  wrap = (-3,-3)
out-lit:   8 /-4 =-2  % = 0     floor=-2.0  wrap = (-2, 0)
out-lit:   7 /-4 =-1  % = 3     floor=-2.0  wrap = (-2,-1)
out-lit:   6 /-4 =-1  % = 2     floor=-2.0  wrap = (-2,-2)
out-lit:   5 /-4 =-1  % = 1     floor=-2.0  wrap = (-2,-3)
out-lit:   4 /-4 =-1  % = 0     floor=-1.0  wrap = (-1, 0)
out-lit:   3 /-4 = 0  % = 3     floor=-1.0  wrap = (-1,-1)
out-lit:   2 /-4 = 0  % = 2     floor=-1.0  wrap = (-1,-2)
out-lit:   1 /-4 = 0  % = 1     floor=-1.0  wrap = (-1,-3)
out-lit:   0 /-4 = 0  % = 0     floor=-0.0  wrap = ( 0, 0)
out-lit:  -1 /-4 = 0  % =-1     floor= 0.0  wrap = ( 0,-1)
out-lit:  -2 /-4 = 0  % =-2     floor= 0.0  wrap = ( 0,-2)
out-lit:  -3 /-4 = 0  % =-3     floor= 0.0  wrap = ( 0,-3)
out-lit:  -4 /-4 = 1  % = 0     floor= 1.0  wrap = ( 1, 0)
out-lit:  -5 /-4 = 1  % =-1     floor= 1.0  wrap = ( 1,-1)
out-lit:  -6 /-4 = 1  % =-2     floor= 1.0  wrap = ( 1,-2)
out-lit:  -7 /-4 = 1  % =-3     floor= 1.0  wrap = ( 1,-3)
out-lit:  -8 /-4 = 2  % = 0     floor= 2.0  wrap = ( 2, 0)
out-lit:  -9 /-4 = 2  % =-1     floor= 2.0  wrap = ( 2,-1)
out-lit: -10 /-4 = 2  % =-2     floor= 2.0  wrap = ( 2,-2)
out-lit: -11 /-4 = 2  % =-3     floor= 2.0  wrap = ( 2,-3)
out-lit: -12 /-4 = 3  % = 0     floor= 3.0  wrap = ( 3, 0)
out-lit: --------long--------12/4
out-lit:  12 / 4 = 3  % = 0     floor= 3.0  wrap = ( 3, 0)
out-lit:  11 / 4 = 2  % = 3     floor= 2.0  wrap = ( 2, 3)
out-lit:  10 / 4 = 2  % = 2     floor= 2.0  wrap = ( 2, 2)
out-lit:   9 / 4 = 2  % = 1     floor= 2.0  wrap = ( 2, 1)
out-lit:   8 / 4 = 2  % = 0     floor= 2.0  wrap = ( 2, 0)
out-lit:   7 / 4 = 1  % = 3     floor= 1.0  wrap = ( 1, 3)
out-lit:   6 / 4 = 1  % = 2     floor= 1.0  wrap = ( 1, 2)
out-lit:   5 / 4 = 1  % = 1     floor= 1.0  wrap = ( 1, 1)
out-lit:   4 / 4 = 1  % = 0     floor= 1.0  wrap = ( 1, 0)
out-lit:   3 / 4 = 0  % = 3     floor= 0.0  wrap = ( 0, 3)
out-lit:   2 / 4 = 0  % = 2     floor= 0.0  wrap = ( 0, 2)
out-lit:   1 / 4 = 0  % = 1     floor= 0.0  wrap = ( 0, 1)
out-lit:   0 / 4 = 0  % = 0     floor= 0.0  wrap = ( 0, 0)
out-lit:  -1 / 4 = 0  % =-1     floor=-1.0  wrap = (-1, 3)
out-lit:  -2 / 4 = 0  % =-2     floor=-1.0  wrap = (-1, 2)
out-lit:  -3 / 4 = 0  % =-3     floor=-1.0  wrap = (-1, 1)
out-lit:  -4 / 4 =-1  % = 0     floor=-1.0  wrap = (-1, 0)
out-lit:  -5 / 4 =-1  % =-1     floor=-2.0  wrap = (-2, 3)
out-lit:  -6 / 4 =-1  % =-2     floor=-2.0  wrap = (-2, 2)
out-lit:  -7 / 4 =-1  % =-3     floor=-2.0  wrap = (-2, 1)
out-lit:  -8 / 4 =-2  % = 0     floor=-2.0  wrap = (-2, 0)
out-lit:  -9 / 4 =-2  % =-1     floor=-3.0  wrap = (-3, 3)
out-lit: -10 / 4 =-2  % =-2     floor=-3.0  wrap = (-3, 2)
out-lit: -11 / 4 =-2  % =-3     floor=-3.0  wrap = (-3, 1)
out-lit: -12 / 4 =-3  % = 0     floor=-3.0  wrap = (-3, 0)
out-lit: --------long--------12/-4
out-lit:  12 /-4 =-3  % = 0     floor=-3.0  wrap = (-3, 0)
out-lit:  11 /-4 =-2  % = 3     floor=-3.0  wrap = (-3,-1)
out-lit:  10 /-4 =-2  % = 2     floor=-3.0  wrap = (-3,-2)
out-lit:   9 /-4 =-2  % = 1     floor=-3.0  wrap = (-3,-3)
out-lit:   8 /-4 =-2  % = 0     floor=-2.0  wrap = (-2, 0)
out-lit:   7 /-4 =-1  % = 3     floor=-2.0  wrap = (-2,-1)
out-lit:   6 /-4 =-1  % = 2     floor=-2.0  wrap = (-2,-2)
out-lit:   5 /-4 =-1  % = 1     floor=-2.0  wrap = (-2,-3)
out-lit:   4 /-4 =-1  % = 0     floor=-1.0  wrap = (-1, 0)
out-lit:   3 /-4 = 0  % = 3     floor=-1.0  wrap = (-1,-1)
out-lit:   2 /-4 = 0  % = 2     floor=-1.0  wrap = (-1,-2)
out-lit:   1 /-4 = 0  % = 1     floor=-1.0  wrap = (-1,-3)
out-lit:   0 /-4 = 0  % = 0     floor=-0.0  wrap = ( 0, 0)
out-lit:  -1 /-4 = 0  % =-1     floor= 0.0  wrap = ( 0,-1)
out-lit:  -2 /-4 = 0  % =-2     floor= 0.0  wrap = ( 0,-2)
out-lit:  -3 /-4 = 0  % =-3     floor= 0.0  wrap = ( 0,-3)
out-lit:  -4 /-4 = 1  % = 0     floor= 1.0  wrap = ( 1, 0)
out-lit:  -5 /-4 = 1  % =-1     floor= 1.0  wrap = ( 1,-1)
out-lit:  -6 /-4 = 1  % =-2     floor= 1.0  wrap = ( 1,-2)
out-lit:  -7 /-4 = 1  % =-3     floor= 1.0  wrap = ( 1,-3)
out-lit:  -8 /-4 = 2  % = 0     floor= 2.0  wrap = ( 2, 0)
out-lit:  -9 /-4 = 2  % =-1     floor= 2.0  wrap = ( 2,-1)
out-lit: -10 /-4 = 2  % =-2     floor= 2.0  wrap = ( 2,-2)
out-lit: -11 /-4 = 2  % =-3     floor= 2.0  wrap = ( 2,-3)
out-lit: -12 /-4 = 3  % = 0     floor= 3.0  wrap = ( 3, 0)
return: 0
END


TEST "ownership of malloced data" UniqueMallocOwner_test <<END
return: 0
END


TEST "collection utils" UtilCollection_test <<END
return: 0
END


TEST "typesafe Variant record" Variant_test <<END
out: Variant.«bool».false
out: Variant.«int».11
out: Variant.«string».lololo
out: Variant.«Time».0:00:00.000
return: 0
END


TEST "verb token based double dispatch helper" VerbFunctionDispatch_test <<END
out-lit: consuming woof ->  'Woof-Woof!'
out-lit: consuming honk ->  'Honk-Honk!'
out-lit: consuming moo ->  'Moo-Moo!'
out-lit: consuming meh ->  'Meh!'
return: 0
END


TEST "VectorTransfer_test" VectorTransfer_test <<END
return: 0
END

